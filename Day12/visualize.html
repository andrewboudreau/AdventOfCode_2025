<!DOCTYPE html>
<html>
<head>
    <title>Day 12: Christmas Tree Farm - Packing Visualizer</title>
    <style>
        * { box-sizing: border-box; }
        body {
            font-family: 'Segoe UI', Tahoma, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            color: #eee;
            margin: 0;
            padding: 0;
            height: 100vh;
            overflow: hidden;
        }
        .app {
            display: flex;
            height: 100vh;
        }

        /* Sidebar with region list */
        .sidebar {
            width: 280px;
            background: rgba(0,0,0,0.3);
            display: flex;
            flex-direction: column;
            border-right: 1px solid rgba(255,255,255,0.1);
        }
        .sidebar-header {
            padding: 15px;
            background: rgba(0,0,0,0.3);
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }
        .sidebar-header h2 {
            margin: 0 0 10px 0;
            color: #f39c12;
            font-size: 18px;
        }
        .stats-row {
            display: flex;
            gap: 20px;
        }
        .stat {
            text-align: center;
        }
        .stat-value {
            font-size: 24px;
            font-weight: bold;
            color: #2ecc71;
        }
        .stat-label {
            font-size: 11px;
            color: #888;
        }

        .region-list {
            flex: 1;
            overflow-y: auto;
            padding: 10px;
        }
        .region-item {
            padding: 10px 12px;
            margin-bottom: 4px;
            background: rgba(255,255,255,0.05);
            border-radius: 6px;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: all 0.2s;
            border: 2px solid transparent;
        }
        .region-item:hover {
            background: rgba(255,255,255,0.1);
        }
        .region-item.selected {
            background: rgba(52, 152, 219, 0.3);
            border-color: #3498db;
        }
        .region-item.solved-yes {
            border-left: 4px solid #2ecc71;
        }
        .region-item.solved-no {
            border-left: 4px solid #e74c3c;
        }
        .region-item .name {
            font-weight: 500;
        }
        .region-item .dims {
            color: #888;
            font-size: 12px;
        }
        .region-item .status {
            font-size: 18px;
        }

        /* Main content */
        .main {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .header {
            padding: 15px 20px;
            background: rgba(0,0,0,0.2);
            border-bottom: 1px solid rgba(255,255,255,0.1);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .header h1 {
            margin: 0;
            color: #f39c12;
            font-size: 24px;
        }

        .shapes-bar {
            display: flex;
            gap: 15px;
            align-items: center;
        }
        .shape-mini {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 5px;
            background: rgba(0,0,0,0.3);
            border-radius: 5px;
        }
        .shape-mini-label {
            font-size: 10px;
            color: #888;
            margin-bottom: 3px;
        }
        .shape-mini-grid {
            display: flex;
            flex-direction: column;
        }
        .shape-mini-row {
            display: flex;
        }
        .shape-mini-cell {
            width: 8px;
            height: 8px;
            margin: 0.5px;
            border-radius: 1px;
        }

        .content {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 20px;
            overflow: auto;
        }

        .region-view {
            text-align: center;
        }
        .region-title {
            font-size: 28px;
            color: #3498db;
            margin-bottom: 10px;
        }
        .region-info {
            color: #888;
            margin-bottom: 20px;
        }
        .region-grid {
            display: inline-block;
            background: rgba(0,0,0,0.5);
            padding: 10px;
            border-radius: 10px;
            border: 3px solid transparent;
        }
        .region-grid.success { border-color: #2ecc71; }
        .region-grid.failure { border-color: #e74c3c; }

        .region-row {
            display: flex;
        }
        .region-cell {
            width: 14px;
            height: 14px;
            margin: 1px;
            border-radius: 2px;
            background: rgba(255,255,255,0.1);
            transition: background 0.1s;
        }

        .result-text {
            margin-top: 20px;
            font-size: 18px;
            font-weight: bold;
        }
        .result-text.success { color: #2ecc71; }
        .result-text.failure { color: #e74c3c; }

        .legend {
            display: flex;
            gap: 15px;
            justify-content: center;
            margin-top: 20px;
            flex-wrap: wrap;
        }
        .legend-item {
            display: flex;
            align-items: center;
            gap: 5px;
            font-size: 12px;
        }
        .legend-color {
            width: 16px;
            height: 16px;
            border-radius: 3px;
        }

        .no-selection {
            color: #666;
            font-size: 18px;
        }

        /* Scrollbar styling */
        .region-list::-webkit-scrollbar {
            width: 8px;
        }
        .region-list::-webkit-scrollbar-track {
            background: rgba(0,0,0,0.2);
        }
        .region-list::-webkit-scrollbar-thumb {
            background: rgba(255,255,255,0.2);
            border-radius: 4px;
        }
        .region-list::-webkit-scrollbar-thumb:hover {
            background: rgba(255,255,255,0.3);
        }

        .solving {
            color: #f39c12;
            animation: pulse 1s infinite;
        }
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
    </style>
</head>
<body>
    <div class="app">
        <div class="sidebar">
            <div class="sidebar-header">
                <h2>Regions</h2>
                <div class="stats-row">
                    <div class="stat">
                        <div class="stat-value" id="fitCount">0</div>
                        <div class="stat-label">Can Fit</div>
                    </div>
                    <div class="stat">
                        <div class="stat-value" id="noFitCount">0</div>
                        <div class="stat-label">Can't Fit</div>
                    </div>
                    <div class="stat">
                        <div class="stat-value" id="pendingCount">0</div>
                        <div class="stat-label">Pending</div>
                    </div>
                </div>
            </div>
            <div class="region-list" id="regionList"></div>
        </div>

        <div class="main">
            <div class="header">
                <h1>Day 12: Christmas Tree Farm</h1>
                <div class="shapes-bar" id="shapesBar"></div>
            </div>
            <div class="content" id="content">
                <div class="no-selection">Select a region from the list to view and solve</div>
            </div>
        </div>
    </div>

    <script>
        const COLORS = [
            '#e74c3c', '#3498db', '#2ecc71', '#f39c12', '#9b59b6', '#1abc9c'
        ];

        // Paste your problem.txt content here
        const inputData = `0:
##.
###
#.#

1:
###
#.#
#.#

2:
.##
##.
#..

3:
###
.#.
###

4:
##.
##.
###

5:
..#
.##
###

37x43: 28 31 34 28 24 23
48x41: 26 34 37 40 39 31
38x39: 37 36 41 43 35 37
46x39: 37 44 48 38 62 48
50x35: 29 29 33 26 24 34
46x47: 26 42 38 46 33 39
49x35: 48 38 47 38 44 51
49x43: 41 41 33 28 42 39
50x38: 35 33 24 34 36 30
46x49: 60 47 68 55 55 66
40x49: 48 45 45 64 55 42
50x37: 34 34 36 30 27 30
4x4: 0 0 0 0 2 0
12x5: 1 0 1 0 2 2
12x5: 1 0 1 0 3 2`;

        let shapes = [];
        let regions = [];
        let solutions = new Map(); // regionIdx -> solution grid or null
        let allVariants = [];
        let selectedRegion = -1;

        function parseInput(input) {
            shapes = [];
            regions = [];
            const lines = input.split('\n');
            let currentShape = null;
            let shapeRow = 0;

            for (const line of lines) {
                if (line.match(/^\d+:$/)) {
                    if (currentShape && currentShape.cells.length > 0) {
                        shapes.push(currentShape);
                    }
                    currentShape = { cells: [], rows: [] };
                    shapeRow = 0;
                } else if (line.match(/^\d+x\d+:/)) {
                    if (currentShape && currentShape.cells.length > 0) {
                        shapes.push(currentShape);
                        currentShape = null;
                    }
                    const match = line.match(/^(\d+)x(\d+):\s*(.+)$/);
                    if (match) {
                        regions.push({
                            w: parseInt(match[1]),
                            h: parseInt(match[2]),
                            counts: match[3].trim().split(/\s+/).map(Number)
                        });
                    }
                } else if (currentShape && line.match(/^[#.]+$/)) {
                    currentShape.rows.push(line);
                    for (let c = 0; c < line.length; c++) {
                        if (line[c] === '#') {
                            currentShape.cells.push([shapeRow, c]);
                        }
                    }
                    shapeRow++;
                }
            }
            if (currentShape && currentShape.cells.length > 0) {
                shapes.push(currentShape);
            }
        }

        function generateVariants(shape) {
            const variants = [];
            const seen = new Set();
            let current = shape.cells.map(c => [...c]);

            for (let flip = 0; flip < 2; flip++) {
                for (let rot = 0; rot < 4; rot++) {
                    const norm = normalize(current);
                    const key = norm.map(c => c.join(',')).sort().join(';');
                    if (!seen.has(key)) {
                        seen.add(key);
                        variants.push(norm);
                    }
                    current = rotate90(current);
                }
                current = flipH(shape.cells);
            }
            return variants;
        }

        function normalize(cells) {
            const minR = Math.min(...cells.map(c => c[0]));
            const minC = Math.min(...cells.map(c => c[1]));
            return cells.map(c => [c[0] - minR, c[1] - minC]);
        }

        function rotate90(cells) {
            return cells.map(c => [c[1], -c[0]]);
        }

        function flipH(cells) {
            return cells.map(c => [c[0], -c[1]]);
        }

        function tryPack(region) {
            const grid = Array(region.h).fill(null).map(() => Array(region.w).fill(-1));
            const shapesToPlace = [];

            region.counts.forEach((count, idx) => {
                for (let i = 0; i < count; i++) {
                    shapesToPlace.push(idx);
                }
            });

            const totalCells = shapesToPlace.reduce((sum, idx) => sum + shapes[idx].cells.length, 0);
            if (totalCells > region.w * region.h) return null;

            let placeId = 0;

            function backtrack(idx) {
                if (idx >= shapesToPlace.length) return true;

                const shapeIdx = shapesToPlace[idx];
                const variants = allVariants[shapeIdx];

                for (const variant of variants) {
                    for (let br = 0; br < region.h; br++) {
                        for (let bc = 0; bc < region.w; bc++) {
                            const valid = variant.every(([dr, dc]) => {
                                const r = br + dr, c = bc + dc;
                                return r >= 0 && r < region.h && c >= 0 && c < region.w && grid[r][c] === -1;
                            });

                            if (valid) {
                                const id = placeId++;
                                variant.forEach(([dr, dc]) => {
                                    grid[br + dr][bc + dc] = shapeIdx * 1000 + id;
                                });

                                if (backtrack(idx + 1)) return true;

                                placeId--;
                                variant.forEach(([dr, dc]) => {
                                    grid[br + dr][bc + dc] = -1;
                                });
                            }
                        }
                    }
                }
                return false;
            }

            return backtrack(0) ? grid : null;
        }

        function renderShapesBar() {
            const bar = document.getElementById('shapesBar');
            bar.innerHTML = '';

            shapes.forEach((shape, idx) => {
                const mini = document.createElement('div');
                mini.className = 'shape-mini';
                mini.innerHTML = `<div class="shape-mini-label">${idx}</div>`;

                const grid = document.createElement('div');
                grid.className = 'shape-mini-grid';

                shape.rows.forEach(row => {
                    const rowDiv = document.createElement('div');
                    rowDiv.className = 'shape-mini-row';
                    for (const ch of row) {
                        const cell = document.createElement('div');
                        cell.className = 'shape-mini-cell';
                        cell.style.background = ch === '#' ? COLORS[idx] : 'rgba(255,255,255,0.1)';
                        rowDiv.appendChild(cell);
                    }
                    grid.appendChild(rowDiv);
                });

                mini.appendChild(grid);
                bar.appendChild(mini);
            });
        }

        function renderRegionList() {
            const list = document.getElementById('regionList');
            list.innerHTML = '';

            regions.forEach((region, idx) => {
                const item = document.createElement('div');
                item.className = 'region-item';
                item.id = `region-item-${idx}`;

                const totalShapes = region.counts.reduce((a, b) => a + b, 0);

                item.innerHTML = `
                    <div>
                        <div class="name">Region ${idx + 1}</div>
                        <div class="dims">${region.w}x${region.h} &bull; ${totalShapes} shapes</div>
                    </div>
                    <div class="status" id="status-${idx}">?</div>
                `;

                item.onclick = () => selectRegion(idx);
                list.appendChild(item);
            });

            updateStats();
        }

        function updateRegionItem(idx) {
            const item = document.getElementById(`region-item-${idx}`);
            const status = document.getElementById(`status-${idx}`);

            item.classList.remove('solved-yes', 'solved-no');

            if (solutions.has(idx)) {
                if (solutions.get(idx)) {
                    item.classList.add('solved-yes');
                    status.textContent = '✓';
                    status.style.color = '#2ecc71';
                } else {
                    item.classList.add('solved-no');
                    status.textContent = '✗';
                    status.style.color = '#e74c3c';
                }
            } else {
                status.textContent = '?';
                status.style.color = '#888';
            }
        }

        function updateStats() {
            let fit = 0, noFit = 0;
            solutions.forEach((sol) => {
                if (sol) fit++;
                else noFit++;
            });
            document.getElementById('fitCount').textContent = fit;
            document.getElementById('noFitCount').textContent = noFit;
            document.getElementById('pendingCount').textContent = regions.length - fit - noFit;
        }

        function selectRegion(idx) {
            // Update selection in list
            document.querySelectorAll('.region-item').forEach(item => {
                item.classList.remove('selected');
            });
            document.getElementById(`region-item-${idx}`).classList.add('selected');

            selectedRegion = idx;
            renderSelectedRegion();

            // Solve if not already solved
            if (!solutions.has(idx)) {
                solveRegion(idx);
            }
        }

        function renderSelectedRegion() {
            const content = document.getElementById('content');
            const region = regions[selectedRegion];

            const shapeCounts = region.counts.map((c, i) => c > 0 ? `${c}x Shape${i}` : null).filter(Boolean).join(', ');

            content.innerHTML = `
                <div class="region-view">
                    <div class="region-title">Region ${selectedRegion + 1}</div>
                    <div class="region-info">${region.w} x ${region.h} grid &bull; ${shapeCounts}</div>
                    <div class="region-grid" id="regionGrid"></div>
                    <div class="result-text" id="resultText"></div>
                    <div class="legend" id="legend"></div>
                </div>
            `;

            const grid = document.getElementById('regionGrid');

            for (let r = 0; r < region.h; r++) {
                const row = document.createElement('div');
                row.className = 'region-row';
                for (let c = 0; c < region.w; c++) {
                    const cell = document.createElement('div');
                    cell.className = 'region-cell';
                    cell.id = `cell-${r}-${c}`;
                    row.appendChild(cell);
                }
                grid.appendChild(row);
            }

            // Render legend
            const legend = document.getElementById('legend');
            shapes.forEach((_, i) => {
                if (region.counts[i] > 0) {
                    const item = document.createElement('div');
                    item.className = 'legend-item';
                    item.innerHTML = `
                        <div class="legend-color" style="background: ${COLORS[i]}"></div>
                        <span>Shape ${i} (${region.counts[i]})</span>
                    `;
                    legend.appendChild(item);
                }
            });

            // If already solved, render the solution
            if (solutions.has(selectedRegion)) {
                renderSolution(solutions.get(selectedRegion));
            } else {
                document.getElementById('resultText').innerHTML = '<span class="solving">Solving...</span>';
            }
        }

        function solveRegion(idx) {
            // Use setTimeout to allow UI to update
            setTimeout(() => {
                const solution = tryPack(regions[idx]);
                solutions.set(idx, solution);
                updateRegionItem(idx);
                updateStats();

                if (selectedRegion === idx) {
                    renderSolution(solution);
                }
            }, 10);
        }

        function renderSolution(solution) {
            const grid = document.getElementById('regionGrid');
            const resultText = document.getElementById('resultText');
            const region = regions[selectedRegion];

            if (solution) {
                grid.classList.add('success');
                grid.classList.remove('failure');
                resultText.className = 'result-text success';
                resultText.textContent = 'All shapes fit!';

                for (let r = 0; r < region.h; r++) {
                    for (let c = 0; c < region.w; c++) {
                        const cell = document.getElementById(`cell-${r}-${c}`);
                        if (solution[r][c] >= 0) {
                            const shapeIdx = Math.floor(solution[r][c] / 1000);
                            cell.style.background = COLORS[shapeIdx];
                        }
                    }
                }
            } else {
                grid.classList.add('failure');
                grid.classList.remove('success');
                resultText.className = 'result-text failure';
                resultText.textContent = 'Cannot fit all shapes';
            }
        }

        // Initialize
        parseInput(inputData);
        allVariants = shapes.map(s => generateVariants(s));
        renderShapesBar();
        renderRegionList();
    </script>
</body>
</html>
