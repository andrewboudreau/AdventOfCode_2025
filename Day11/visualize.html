<!DOCTYPE html>
<html>
<head>
    <title>Day 11 - Graph Visualization</title>
    <style>
        body { margin: 0; overflow: hidden; font-family: Arial, sans-serif; background: #1a1a2e; }
        canvas { display: block; }
        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            background: rgba(0,0,0,0.8);
            padding: 15px;
            border-radius: 8px;
            max-width: 320px;
        }
        #info h3 { margin: 0 0 10px 0; color: #4a90d9; }
        .stat-row { display: flex; justify-content: space-between; margin: 5px 0; }
        .stat-label { color: #888; }
        .stat-value { color: #fff; font-weight: bold; }
        #legend {
            position: absolute;
            top: 10px;
            right: 10px;
            color: white;
            background: rgba(0,0,0,0.8);
            padding: 15px;
            border-radius: 8px;
        }
        #legend h4 { margin: 0 0 10px 0; color: #4a90d9; }
        .legend-item { display: flex; align-items: center; margin: 8px 0; }
        .legend-dot {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            margin-right: 10px;
            box-shadow: 0 0 8px currentColor;
        }
        #controls {
            position: absolute;
            bottom: 10px;
            left: 10px;
            color: #888;
            background: rgba(0,0,0,0.8);
            padding: 10px 15px;
            border-radius: 8px;
            font-size: 12px;
        }
        .highlight { color: #ffaa00; }
    </style>
</head>
<body>
    <div id="info">
        <h3>Day 11: Reactor Graph</h3>
        <div class="stat-row">
            <span class="stat-label">Nodes:</span>
            <span class="stat-value" id="nodeCount">-</span>
        </div>
        <div class="stat-row">
            <span class="stat-label">Edges:</span>
            <span class="stat-value" id="edgeCount">-</span>
        </div>
        <hr style="border-color: #333; margin: 10px 0;">
        <div class="stat-row">
            <span class="stat-label">Part 1 (you → out):</span>
            <span class="stat-value" id="part1Count">-</span>
        </div>
        <div class="stat-row">
            <span class="stat-label">Part 2 (svr → out via dac+fft):</span>
            <span class="stat-value highlight" id="part2Count">-</span>
        </div>
    </div>

    <div id="legend">
        <h4>Node Legend</h4>
        <div class="legend-item">
            <div class="legend-dot" style="background: #2ecc71; color: #2ecc71;"></div>
            <span><b>you</b> - Part 1 start</span>
        </div>
        <div class="legend-item">
            <div class="legend-dot" style="background: #00bcd4; color: #00bcd4;"></div>
            <span><b>svr</b> - Part 2 start</span>
        </div>
        <div class="legend-item">
            <div class="legend-dot" style="background: #ff9800; color: #ff9800;"></div>
            <span><b>dac</b> - Required waypoint</span>
        </div>
        <div class="legend-item">
            <div class="legend-dot" style="background: #ffeb3b; color: #ffeb3b;"></div>
            <span><b>fft</b> - Required waypoint</span>
        </div>
        <div class="legend-item">
            <div class="legend-dot" style="background: #e74c3c; color: #e74c3c;"></div>
            <span><b>out</b> - End node</span>
        </div>
        <div class="legend-item">
            <div class="legend-dot" style="background: #4a90d9; color: #4a90d9;"></div>
            <span>Regular node</span>
        </div>
    </div>

    <div id="controls">
        Drag to rotate | Scroll to zoom | Right-drag to pan
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script>
        // Graph data from problem input
        const sampleGraph = `ojt: rum xgy guf mqs
srg: mqo ufz
lwb: sxb wsf
pkk: ium
evd: els stn oln
ukv: ocs vxd tfl
fyk: ikm fox nok
bfd: evd kjy smb
wqy: srg tgk
mix: cmj ufz mqo
rew: avm nrs vot mqv
tri: hex zvw yuq jeo
lbo: dgt ica yws pkk qwp
fcn: smr
msw: ssg qtf aem
zwf: zvl qfe
epg: xax pzu
mmw: dhg
hbd: cji vrr ysi bfd
czn: wld cgm gqw tbz
qdh: tvc
dwh: hux lkt lad
ayq: bzr van
lor: xrf jwh
gkc: pwk hgf cdw
jxm: ehg xet fqn
qft: qnl evl
pek: cvj flu
rmo: rxx hbd
nwe: out
liy: tcc rjb pda
xft: azu upo itg
ojy: cfp
nuq: cvj asi ufb flu
ogq: oov dtc ppz
rjb: cmj ufz mqo you
rdz: cvj ozn ufb asi flu
qoa: dgt yws pkk qwp
mbw: lik rmf nqr
yes: ccc
uit: ysj ngh rew
hfa: sum clx
jqd: ozn flu cvj
xfi: dyo zqy
lym: kht
sqm: rdc oao
jmw: nzq
sgq: bju lzc bwx
xjr: lcx kpp mvl fto
tdg: vds kuh
aww: der lwb ijy rjq mof obb fmi unx eqn vyj skb wqa aer tas stx vpf oas fzq gfy pua
rmb: euk xic
hwg: fto xmd kpp lcx
nce: mmd sum clx
ult: ufb ozn
fbj: lcx xmd fto mvl
tgk: you mqo cmj
ppz: nqr
vty: ppz lok mbw dtc oov
eit: xvj ccc
dtc: xvf nqr lik rmf
qso: out
tcc: ufz you
gwp: xur pto ayw rmb
ibm: bwe fuv zkc
onk: ibe gdf
jax: qnl evl nzq
vct: ozn flu asi ufb cvj
bju: sfu azu itg
amz: you mqo ufz
ozn: rqf jzc onk qoa jzs lbk tog fhz vkr hty pnw tej hmv erl mcm msw qky umv
eux: kuc xpq gxc
vmi: mqo you cmj
lft: sum clx fbs
lgv: ufz mqo
quc: npv
bzr: leu ehk
bwx: sfu upo azu
cnk: mmd fbs
xpq: qyh
zon: bwe npv zkc
pqe: mqo ufz you
rks: tje isv
hmv: gdf
evl: tbt ftw lco
vux: rxx zbg
yoa: trv
tpq: cvj
jws: tpq lyi jqd nuq rdz
qzs: clx fbs mmd
vds: amz pid xax
xfg: fof
xak: xjo gwd rcb wzr
erl: aem vux ssg qtf rmo
tzu: out
oht: xmd fto mvl kpp
ogz: ojy gdf
yly: czn fjq
nrs: you ufz mqo
rna: mvl
ins: fbs gyg sum
vwu: ilb wqy bud bba
nxi: npt kht
gfx: hfd sia
itg: cvj ufb asi ozn
nxy: fto xmd
zcq: yoa wvx
jok: rna msk sna
vqb: tdg shp gru
vep: ocg bvi znu
tqa: ame pfb eux
eer: out
lna: blf uph bzr
dyo: ypx kth wcn
ejr: vct tpt joe
vpk: jer fmw erg hwg
lkt: yrk
bok: xet
anx: tpt joe atl vct
yrk: mqs guf
vpd: zle tdg gru shp
htv: auw oyn pek ikf
icv: fto xmd lcx
wfb: you cmj
lrx: xet fqn tzu
wjh: clx gyg sum fbs
xet: out
hgf: fto
tvc: smr tyc irq
gra: cdw hgf rqb
brr: xft mbe
fui: cgm wld ahr gqw
kht: bqw fmu
asi: rqf jzc hmv pnw vkr umv jzs jtv erl msw
dxr: rjk rgc gfg
xic: nys xak xxh
smr: cmj you ufz mqo
bvi: xjr bgh igy oht bzh
fkj: bqr pto rmb
nnm: fbs gyg
zih: tzu fqn ehg xet
npb: thy zao
bhz: you
eny: lor
fqn: out
sna: lcx kpp xmd mvl fto
azu: ozn asi flu
ilh: acj vdg zpt zcq qwn qft aic fay fjj ycs wdh cyp ymi gfx tjs fug jmw abi nih
lad: ojt tqj yrk
abh: ikm nmg
mof: dxr yal
xtl: jar wsf
aem: rxx hbd qdy
clx: veu yes fej yfb zdm vwu vpd tcj imw bfo sak fpe vqb lwp apx uit ysq jsl tyr ahw wec rzx
leu: xjj tji qzs
zww: isz sgq brr
jvq: htl iao uix
cbk: nuq rdz lyi
qfe: out
bei: xxh nys
qsk: you ufz cmj
lik: jgk wce nwe
hfd: qnr ult
bqr: euk xic
fxy: nxi iyn
wvb: fof dzk
ill: weg vpk yqv toh
srl: gfg
svr: xzk ilh xkb gtf ebx
kko: eph czn fui
fay: wya wvx
ikm: qie
sju: lrx
lbk: gdf
fjg: hfn ibm
vso: jwh scd ins xrf
vsi: jxm zih
iao: lcx xmd mvl
ley: out
apx: ysj
pnw: hak hvg fft
fej: ngh ysj
xkz: wjb vso xxn aty
lok: rmf nqr xvf
tjs: nzq
gdf: yck eqp
ubl: gru shp
xdh: anb dzk fof
afd: teg
rbe: out
vdg: nzq evl
ejz: dgg
hux: ojt tqj bgr
xxn: scd
bgh: lcx kpp xmd mvl
wld: dep cnk nnm hfa
xgj: fxy ups tjo
guy: zgs qdh mmw oif
ocs: wjh nce lft
vot: mqo
kav: cny gjt aps
oov: rmf nqr
jwh: mmd fbs clx gyg
hfn: bwe fuv
cac: ocs dci
xjo: niz qso
yta: van
zpt: kfx mam cwc
ame: kuc lkx gxc
hvg: qxn
vdq: out
yal: rgc gfg
ssg: rxx
qbe: dhh oas vpf tas skb eqn unx xtl rjq ijy lwb blk der
joe: flu
ccc: dac liy lqv
pua: dxr sru
oas: nfc
lbv: ibm hfn quc zon vtx
wqa: tje zkz
oif: dhg
pnh: fui
mzt: ubm ame pfb oia
tbt: cvj ozn flu ufb asi
jtv: ojy ibe
izw: xix lvg
avm: cmj ufz mqo
gjt: paa
txn: guy
van: teg
vkn: mvl
qie: ibm hfn zon quc vtx
hsz: npt lwt
ayy: yuq jeo zvw
igy: fto xmd
ptz: vep rdc mhx
wqi: sgq
tjo: hsz sfy lym
epd: oln qbe els
tna: els stn aww
mhx: ocg cwu bvi
bfo: kvy
jsl: eqd wzw
hak: rms tna
akf: kpp mvl
sfu: ozn ufb asi
erg: lcx kpp xmd mvl
jar: uht gra
rum: els stn
anb: prd
tyr: guy
stn: vpf gfy ijy mof der skb rks obb xtl fmi unx
ayw: bei
mqo: kav thd alq qcs ckk fyk ojj mzt abh tqa
tje: akf icv
lzc: sfu azu
gtf: jmw fay jax val qwn zcq zpt mnc cyp wdh rkh
yck: stn els aww
kgq: wjb vso lor aty
fmu: sum clx gyg mmd
ubm: lkx
sia: gcn
huh: ntp vsi
jzc: ssg vux aem
yfb: bud
nih: mam
fto: xgj byk yta xkz pnh lna
zvl: out
qwn: hfd sia
dzk: qfe prd
jxj: eqd mzb
tas: sqm dgg ptz
rfz: ufz mqo cmj
ecn: rna sna oks
aer: yal srl
vpf: jar
ups: hsz sfy lym
bqw: sum clx fbs mmd
cdw: mvl xmd lcx
veu: wzw
ikh: brr
fzq: wsq dxr
irq: cmj
rmf: jgk nwe ykg wce mdv
dhe: zao
npv: gxk ezs
ehg: out
aiy: xur bqr rmb ayw
els: mof lwb rjq der ejz rks skb unx xtl fmi stx vpf tas aer dhh pua fzq gfy
nys: xjo wzr rcb
bba: nkp
mxd: anb zwf fof
gru: vds epg
ppa: fbs gyg
lwt: fmu hrc bqw
gqw: dep hfa
pwk: xmd kpp lcx
lwp: ilb
zvw: vty nbi ogq
guf: stn oln els aww
ocv: kzf huh
wsf: gkc uht
buy: vhu qdh oif
xvf: mdv wce nwe jgk
blf: leu ehk
zgs: tvc dhg fcn
fhd: aty vso xxn
fmi: dhe npb avc mvk bxo
fox: lbv fjg
iqo: msk ocd oks
ufb: fhz erl lbk ogz umv vkr pnw qoa onk tej rqf jzc hmv
sru: gfg
rcb: rbe
teg: tji keq ppa
ikf: ufb asi flu
bxo: thy nvf
weg: fmw
lkx: xfi
qky: xxs dwh wat
zqy: eer ypx
ckk: ocv gga xpa
qnl: ftw lco
tcj: hcg
rxx: dyl cji
sps: mqo
snz: fox nmg ikm
upo: asi ozn
kuc: qyh wot
znu: igy
niz: out
ocd: mvl fto xmd
zle: vds epg kuh
gga: spp kzf
tbz: gyk dep cnk hfa
zkc: ley
cqr: xfg mxd
ezs: out
cwc: cbk
nbi: ppz lok oov
wce: out
ntp: lrx bok
vyj: dgg ptz
atl: ozn
uph: leu ehk teg
mcm: rmo aem
skb: mvk
pzu: you
dgt: ium ykj
oyn: asi flu ufb
jeo: vty nbi
ehk: tji qzs keq ppa
ysj: nrs avm vot
pxi: stn oln
gxc: yed qyh wot
cwu: xjr igy oht
qez: ayw pto xur bqr
jgp: asi cvj
dep: clx gyg sum
ahw: bba bud ilb wqy
keq: clx gyg
tyc: ufz
wjb: scd
bns: kfx mam vjd
zkz: fbj icv
eph: tbz
xmd: fhd bwh cac pnh gmc izt kgq ayq yta xkz kko yly
ica: jzl ykj
asz: blf
oln: ijy lwb mof obb unx vyj ejz wqa aer tas vpf fzq gfy pua
iyn: kht lwt
alq: eux oia ubm
shp: epg
fft: rms qxn tna
ijy: jvq mms nfc
rjk: ecn
euz: anb dzk
euk: xak
fof: zvl
obb: isv tje
wot: zqy
eqn: mms nfc
yed: uef dyo
mnc: zqk lgu izw asb
tej: yws dgt ica
mrh: gyg mmd fbs
bgr: mqs epd
mvk: zao ill
gyk: fbs gyg
ebx: qft jax fjj fay rkh acj vdg zpt mnc zcq qwn val gfx fug jmw abi nih ycs wdh cyp ymi
wya: fio anx
qcs: bqr ayw
kth: out
kfx: jws yoz cbk
nqr: nwe ykg wce jgk
dci: ufh nce mrh
kjy: qbe els stn aww
xrb: cny aps
trv: vct atl joe
paa: wvb euz
zdm: ngh rew qnk
qnr: asi
ddh: gcn ult
wvx: anx ejr trv
vih: lrx jxm bok
xvj: lqv liy
xax: cmj you mqo
wzw: wfb mix rfz sps
mbe: azu upo itg
rdc: ocg
thy: weg toh
ibe: yck pxi cfp
eqd: sps wfb mix rfz qsk
qtf: zbg rxx hbd qdy
ymi: xer
lgu: kop xix lvg
xxs: hux tth
blk: wsf sxb
fbs: rzx uit wec vwu veu sak fpe apx
toh: jer hwg fmw
xkb: zpt zcq bns mnc gfx
rqf: xxs
stx: jar wsf
gmc: eph fjq
kuh: xax pzu pid amz
xix: ikf pek oyn
nkp: cmj you ufz
mqv: cmj
ufz: gwp kav thd ojj ayy fyk mzt tri snz csm tqa abh xrb alq qez qcs fkj lae aiy
tnv: asi cvj
auw: ozn
mms: htl vkn iao
gxf: kzf huh spp
yuq: vty
sxb: gkc
dgg: mhx rdc vep
dhg: irq pqe
isz: xft lzc bwx
xzm: you cmj
ngh: mqv vot lgv
fjq: tbz ahr gqw cgm
cyp: zqk
mam: qmc
byk: vxd dci
dyl: rzq
fpe: hcg ccc
mvl: xkz ayq kgq izt vkq lna pnh gmc yly byk bwh asz cew fhd xgj cac
vkq: vso wjb lor
sfy: npt kht
cew: czn eph fui
ftw: ufb ozn
smb: stn oln aww
tqj: xgy mqs rum epd
vrr: rzq smb
vxd: mrh ufh
mmd: tyr ubl fpe sak bfo veu lwp ysq rzx vpd eit tcj fej ahw txn yfb vwu
xur: xic bei
msk: lcx kpp mvl fto
umv: qwp pkk dgt
xgy: qbe oln aww
aps: cqr umy
cvj: qky ogz umv pnw tej lbk jzs tog fhz vkr hty lbo rqf jzc qoa onk
aic: kfx vjd mam
hcg: lqv liy
qnk: nrs avm mqv vot
yws: jzl
qmc: rdz jqd lyi tpq
nok: fjg lbv
jgk: out
thd: gga
gfg: jok ecn iqo
gfy: sqm
gcn: cvj flu ufb asi
dhh: avc
xer: gcn ult
uht: cdw
xjj: sum gyg
prd: out
asb: lvg htv kop
cmj: gwp kav thd ayy mzt snz csm tqa abh zce alq qcs qez lae
lae: aps gjt cny
hex: vty nbi ogq
ykj: oln stn qbe
zce: cny
kzf: ntp vsi vih
ojj: ocv gxf
yqv: hwg
zqk: lvg kop
aty: ins
npt: bqw fmu hrc
pid: cmj you ufz
wdh: wvx wya
sum: jxj tcj imw ysq jsl sak veu
fio: jgp tpt joe atl vct
nfc: uix nxy
mno: you
wec: mzb eqd
qyh: dyo zqy uef
pto: bei xic euk
spp: vsi sju ntp
der: bxo
vjd: cbk qmc jws yoz
cfp: oln stn els qbe aww
eqp: oln qbe stn els
csm: yuq jeo zvw
mdv: out
fmw: mvl
yoz: lyi
acj: zqk lgu izw
umy: wvb euz xdh
kop: tnv ikf oyn auw
ysq: ccc xvj
cny: umy paa
val: kfx vjd
ycs: ddh
jzl: els qbe
avc: thy nvf ill
rzx: qnk
bwh: afd blf van uph
qdy: cji bfd
flu: jzc qoa lbo qky umv hty jzs mcm
pgw: fmw erg jer
you: qcs ckk fkj xrb csm lae
jer: kpp
wsq: rgc
sak: guy kvy buy
rqb: mvl xmd
bud: mno xzm nkp
xrf: sum gyg
vkr: xxs wat dwh
gxk: out
nzq: lco
lcx: ukv yta eny vkq fhd gmc pnh uor cew
rjq: tje zkz
fhz: fft hak
xxh: xjo gwd
lvg: oyn
zbg: ysi
mqs: aww stn qbe els oln
uor: tjo ups
jzs: hvg fft
ufh: mmd sum
xpa: huh kzf spp
oia: lkx xpq
imw: kvy guy
tpt: ufb asi
mzb: wfb rfz sps
unx: sqm
ykg: out
rzq: els aww
hrc: fbs clx
tfl: lft nce ufh wjh
fuv: vdq gxk ezs
abi: wqi
ysi: kjy
rkh: zww wqi ikh
vtx: fuv npv zkc
wzr: niz rbe qso
wat: lkt hux tth lad
rgc: iqo jok
hty: vux rmo
ium: stn els oln aww
pfb: kuc
xzk: qft gfx fug fjj abi jmw fay ycs vdg mnc
uix: xmd fto
fug: ikh
qwp: ium ykj jzl
lco: asi cvj
cji: evd rzq kjy
scd: gyg clx sum mmd
isv: icv akf orc
pda: cmj
ypx: out
qxn: aww qbe oln stn els
gyg: apx lwp vqb yes fpe sak bfo jsl ysq jxj txn fej wec zdm rzx tcj eit
kvy: oif mmw vhu zgs
zao: toh pgw yqv
cgm: nnm gyk
uef: kth
wcn: out
lqv: vmi
nvf: yqv weg toh
nmg: lbv
htl: kpp lcx
oao: znu cwu
fjj: ikh wqi
orc: xmd mvl fto
tji: mmd fbs clx sum
gwd: qso niz
ilb: nkp xzm mno
ahr: dep
ocg: bgh xjr igy oht bzh
dac: pda vmi bhz rjb tcc
kpp: bwh xgj byk cew uor gmc
lyi: cvj ufb ozn
bzh: fto mvl lcx kpp
tog: qwp
izt: fxy
vhu: fcn
rms: els qbe oln
tth: yrk tqj ojt
bwe: vdq gxk ley
oks: mvl xmd kpp`;

        // Special nodes for coloring
        const SPECIAL_NODES = {
            'you': 0x2ecc71,  // Green - Part 1 start
            'svr': 0x00bcd4,  // Cyan - Part 2 start
            'dac': 0xff9800,  // Orange - Required waypoint
            'fft': 0xffeb3b,  // Yellow - Required waypoint
            'out': 0xe74c3c   // Red - End
        };

        function parseGraph(text) {
            const lines = text.trim().split('\n');
            const nodes = new Set();
            const edges = [];

            lines.forEach(line => {
                const [node, neighbors] = line.split(':').map(s => s.trim());
                nodes.add(node);
                neighbors.split(/\s+/).forEach(n => {
                    if (n) {
                        nodes.add(n);
                        edges.push({ from: node, to: n });
                    }
                });
            });

            return { nodes: Array.from(nodes), edges };
        }

        // Build adjacency list
        function buildAdjacency(graph) {
            const adj = {};
            graph.nodes.forEach(n => adj[n] = []);
            graph.edges.forEach(e => adj[e.from].push(e.to));
            return adj;
        }

        // Count paths with memoization
        function countPaths(adj, start, end) {
            const memo = {};
            function dfs(current) {
                if (current === end) return 1;
                if (memo[current] !== undefined) return memo[current];
                let count = 0;
                for (const neighbor of adj[current] || []) {
                    count += dfs(neighbor);
                }
                return memo[current] = count;
            }
            return dfs(start);
        }

        // Count paths through both required nodes (Part 2)
        function countPathsVia(adj, start, end, req1, req2) {
            const memo = {};
            function dfs(current, v1, v2) {
                if (current === req1) v1 = true;
                if (current === req2) v2 = true;
                if (current === end) return (v1 && v2) ? 1 : 0;

                const key = `${current}|${v1}|${v2}`;
                if (memo[key] !== undefined) return memo[key];

                let count = 0;
                for (const neighbor of adj[current] || []) {
                    count += dfs(neighbor, v1, v2);
                }
                return memo[key] = count;
            }
            return dfs(start, false, false);
        }

        // Initialize
        const graphData = parseGraph(sampleGraph);
        const adjacency = buildAdjacency(graphData);

        // Scene setup
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x1a1a2e);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 0, 50);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;

        // Create node positions using force-directed layout
        const nodePositions = {};
        const nodeCount = graphData.nodes.length;

        // Initial random positions
        graphData.nodes.forEach((node, i) => {
            const angle = (i / nodeCount) * Math.PI * 2;
            const radius = 20 + Math.random() * 10;
            nodePositions[node] = {
                x: Math.cos(angle) * radius + (Math.random() - 0.5) * 10,
                y: Math.sin(angle) * radius + (Math.random() - 0.5) * 10,
                z: (Math.random() - 0.5) * 15,
                vx: 0, vy: 0, vz: 0
            };
        });

        // Fix special nodes in strategic positions
        const fixedNodes = {
            'svr': { x: -35, y: 15, z: 0 },
            'you': { x: -35, y: -15, z: 0 },
            'dac': { x: 0, y: -10, z: 5 },
            'fft': { x: 0, y: 10, z: -5 },
            'out': { x: 35, y: 0, z: 0 }
        };

        Object.entries(fixedNodes).forEach(([node, pos]) => {
            if (nodePositions[node]) {
                nodePositions[node].x = pos.x;
                nodePositions[node].y = pos.y;
                nodePositions[node].z = pos.z;
            }
        });

        // Force-directed simulation
        for (let iter = 0; iter < 150; iter++) {
            // Repulsion
            graphData.nodes.forEach(n1 => {
                if (fixedNodes[n1]) return;
                graphData.nodes.forEach(n2 => {
                    if (n1 !== n2) {
                        const p1 = nodePositions[n1];
                        const p2 = nodePositions[n2];
                        const dx = p1.x - p2.x;
                        const dy = p1.y - p2.y;
                        const dz = p1.z - p2.z;
                        const dist = Math.sqrt(dx*dx + dy*dy + dz*dz) + 0.1;
                        const force = 8 / (dist * dist);
                        p1.vx += dx / dist * force;
                        p1.vy += dy / dist * force;
                        p1.vz += dz / dist * force;
                    }
                });
            });

            // Attraction along edges
            graphData.edges.forEach(e => {
                const p1 = nodePositions[e.from];
                const p2 = nodePositions[e.to];
                if (!p1 || !p2) return;
                const dx = p2.x - p1.x;
                const dy = p2.y - p1.y;
                const dz = p2.z - p1.z;
                const dist = Math.sqrt(dx*dx + dy*dy + dz*dz) + 0.1;
                const force = dist * 0.02;
                if (!fixedNodes[e.from]) {
                    p1.vx += dx / dist * force;
                    p1.vy += dy / dist * force;
                    p1.vz += dz / dist * force;
                }
                if (!fixedNodes[e.to]) {
                    p2.vx -= dx / dist * force;
                    p2.vy -= dy / dist * force;
                    p2.vz -= dz / dist * force;
                }
            });

            // Apply velocities
            graphData.nodes.forEach(n => {
                if (fixedNodes[n]) return;
                const p = nodePositions[n];
                p.x += p.vx * 0.1;
                p.y += p.vy * 0.1;
                p.z += p.vz * 0.1;
                p.vx *= 0.85;
                p.vy *= 0.85;
                p.vz *= 0.85;
            });
        }

        // Create node meshes
        const nodeMeshes = {};
        graphData.nodes.forEach(node => {
            const isSpecial = SPECIAL_NODES[node];
            const size = isSpecial ? 0.8 : 0.3;
            const geometry = new THREE.SphereGeometry(size, 32, 32);
            const color = SPECIAL_NODES[node] || 0x4a90d9;

            const material = new THREE.MeshPhongMaterial({
                color: color,
                emissive: color,
                emissiveIntensity: isSpecial ? 0.5 : 0.2
            });
            const mesh = new THREE.Mesh(geometry, material);
            const pos = nodePositions[node];
            mesh.position.set(pos.x, pos.y, pos.z);
            mesh.userData = { name: node, isSpecial: !!isSpecial };
            scene.add(mesh);
            nodeMeshes[node] = mesh;

            // Add glow ring for special nodes
            if (isSpecial) {
                const ringGeom = new THREE.RingGeometry(size * 1.3, size * 1.6, 32);
                const ringMat = new THREE.MeshBasicMaterial({
                    color: color,
                    transparent: true,
                    opacity: 0.4,
                    side: THREE.DoubleSide
                });
                const ring = new THREE.Mesh(ringGeom, ringMat);
                ring.position.copy(mesh.position);
                scene.add(ring);
                mesh.userData.ring = ring;
            }
        });

        // Create edges
        graphData.edges.forEach(e => {
            const p1 = nodePositions[e.from];
            const p2 = nodePositions[e.to];
            if (!p1 || !p2) return;

            // Check if this edge connects special nodes
            const isSpecialEdge = SPECIAL_NODES[e.from] || SPECIAL_NODES[e.to];

            const points = [
                new THREE.Vector3(p1.x, p1.y, p1.z),
                new THREE.Vector3(p2.x, p2.y, p2.z)
            ];
            const geometry = new THREE.BufferGeometry().setFromPoints(points);
            const material = new THREE.LineBasicMaterial({
                color: isSpecialEdge ? 0x888899 : 0x444466,
                transparent: true,
                opacity: isSpecialEdge ? 0.7 : 0.3
            });
            const line = new THREE.Line(geometry, material);
            scene.add(line);
        });

        // Labels for special nodes only (to keep it clean)
        Object.keys(SPECIAL_NODES).forEach(node => {
            if (!nodePositions[node]) return;

            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = 128;
            canvas.height = 64;

            ctx.fillStyle = '#' + SPECIAL_NODES[node].toString(16).padStart(6, '0');
            ctx.font = 'bold 32px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(node, 64, 42);

            const texture = new THREE.CanvasTexture(canvas);
            const spriteMat = new THREE.SpriteMaterial({ map: texture, transparent: true });
            const sprite = new THREE.Sprite(spriteMat);
            const pos = nodePositions[node];
            sprite.position.set(pos.x, pos.y + 1.5, pos.z);
            sprite.scale.set(3, 1.5, 1);
            scene.add(sprite);
        });

        // Lighting
        const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
        scene.add(ambientLight);

        const pointLight = new THREE.PointLight(0xffffff, 1, 200);
        pointLight.position.set(30, 30, 30);
        scene.add(pointLight);

        const pointLight2 = new THREE.PointLight(0x4a90d9, 0.6, 200);
        pointLight2.position.set(-30, -30, 30);
        scene.add(pointLight2);

        // Update info
        const part1 = countPaths(adjacency, 'you', 'out');
        const part2 = countPathsVia(adjacency, 'svr', 'out', 'dac', 'fft');

        document.getElementById('nodeCount').textContent = graphData.nodes.length.toLocaleString();
        document.getElementById('edgeCount').textContent = graphData.edges.length.toLocaleString();
        document.getElementById('part1Count').textContent = part1.toLocaleString();
        document.getElementById('part2Count').textContent = part2.toLocaleString();

        // Traveling particles
        const particles = [];
        const PARTICLE_COUNT = 15;
        const PARTICLE_SPEED = 0.02;

        function createParticle(startNode, color) {
            const geom = new THREE.SphereGeometry(0.25, 16, 16);
            const mat = new THREE.MeshBasicMaterial({
                color: color,
                transparent: true,
                opacity: 0.9
            });
            const mesh = new THREE.Mesh(geom, mat);
            const pos = nodePositions[startNode];
            mesh.position.set(pos.x, pos.y, pos.z);
            scene.add(mesh);

            return {
                mesh,
                currentNode: startNode,
                targetNode: null,
                progress: 0,
                color
            };
        }

        function moveParticle(p) {
            // Need a new target?
            if (!p.targetNode || p.progress >= 1) {
                const neighbors = adjacency[p.currentNode] || [];
                if (neighbors.length === 0 || p.currentNode === 'out') {
                    // Reached end - respawn
                    const starts = ['svr', 'you'];
                    const start = starts[Math.floor(Math.random() * starts.length)];
                    const pos = nodePositions[start];
                    p.mesh.position.set(pos.x, pos.y, pos.z);
                    p.currentNode = start;
                    p.targetNode = null;
                    p.progress = 0;
                    p.mesh.material.color.setHex(start === 'svr' ? 0x00bcd4 : 0x2ecc71);
                    return;
                }
                // Pick random neighbor
                p.currentNode = p.targetNode || p.currentNode;
                p.targetNode = neighbors[Math.floor(Math.random() * neighbors.length)];
                p.progress = 0;

                // Change color when hitting waypoints
                if (p.targetNode === 'dac') p.mesh.material.color.setHex(0xff9800);
                else if (p.targetNode === 'fft') p.mesh.material.color.setHex(0xffeb3b);
                else if (p.targetNode === 'out') p.mesh.material.color.setHex(0xe74c3c);
            }

            // Move toward target
            p.progress += PARTICLE_SPEED;
            const from = nodePositions[p.currentNode];
            const to = nodePositions[p.targetNode];
            if (from && to) {
                p.mesh.position.x = from.x + (to.x - from.x) * p.progress;
                p.mesh.position.y = from.y + (to.y - from.y) * p.progress;
                p.mesh.position.z = from.z + (to.z - from.z) * p.progress;
            }
        }

        // Create initial particles
        for (let i = 0; i < PARTICLE_COUNT; i++) {
            const start = i < PARTICLE_COUNT / 2 ? 'svr' : 'you';
            const color = start === 'svr' ? 0x00bcd4 : 0x2ecc71;
            const p = createParticle(start, color);
            // Stagger start times
            p.progress = Math.random();
            particles.push(p);
        }

        // Animation
        let time = 0;
        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            time += 0.02;

            // Move particles
            particles.forEach(moveParticle);

            // Pulse special nodes
            Object.keys(SPECIAL_NODES).forEach(node => {
                const mesh = nodeMeshes[node];
                if (mesh) {
                    const scale = 1 + Math.sin(time * 2) * 0.1;
                    mesh.scale.set(scale, scale, scale);
                    if (mesh.userData.ring) {
                        mesh.userData.ring.rotation.x = time;
                        mesh.userData.ring.rotation.y = time * 0.7;
                    }
                }
            });

            renderer.render(scene, camera);
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();
    </script>
</body>
</html>
